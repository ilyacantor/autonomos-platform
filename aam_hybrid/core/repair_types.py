"""
Repair Types for AutonomOS Auto-Repair Agent

This module defines data structures for schema drift repair operations,
including repair suggestions, confidence scoring, and HITL workflow metadata.

Key Types:
- RepairSuggestion: LLM-generated repair proposal with confidence scoring
- RepairAction: Enum for repair decision (auto_applied, hitl_queued, rejected)
"""

from typing import Any, Dict, Optional, List
from pydantic import BaseModel, Field
from datetime import datetime
from enum import Enum


class RepairAction(str, Enum):
    """Possible actions taken by the repair agent"""
    AUTO_APPLIED = "auto_applied"
    HITL_QUEUED = "hitl_queued"
    REJECTED = "rejected"


class RepairSuggestion(BaseModel):
    """
    Repair suggestion generated by Auto-Repair Agent.
    
    Contains field mapping suggestion with confidence scoring and
    metadata for HITL workflow and observability.
    
    Confidence Tiers:
    - >= 0.85: Auto-applied (high confidence)
    - 0.6 - 0.85: Queued for HITL review (medium confidence)
    - < 0.6: Rejected (low confidence)
    """
    field_name: str = Field(..., description="Drifted field name from source system")
    
    original_value: Optional[Any] = Field(
        None, description="Sample value from drifted field (for context)"
    )
    
    suggested_mapping: str = Field(
        ..., description="Canonical field name suggested by LLM"
    )
    
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="LLM confidence score (0.0-1.0)"
    )
    
    confidence_reason: str = Field(
        ..., description="Explanation for confidence score (from LLM)"
    )
    
    rag_similarity_count: int = Field(
        0, ge=0, description="Number of similar historical mappings found by RAG"
    )
    
    repair_action: RepairAction = Field(
        ..., description="Action taken: auto_applied, hitl_queued, or rejected"
    )
    
    queued_for_hitl: bool = Field(
        False, description="Whether this suggestion is queued for human review"
    )
    
    transformation: Optional[str] = Field(
        None, description="Transformation function suggested (e.g., 'direct', 'lowercase')"
    )
    
    timestamp: str = Field(
        default_factory=lambda: datetime.utcnow().isoformat(),
        description="When this suggestion was generated"
    )
    
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata (LLM model, RAG context, etc.)"
    )


class RepairBatch(BaseModel):
    """
    Batch of repair suggestions for a drift event.
    
    Aggregates multiple field repairs with summary statistics.
    """
    drift_event_id: str = Field(..., description="ID of drift event that triggered repair")
    
    suggestions: List[RepairSuggestion] = Field(
        default_factory=list, description="Individual field repair suggestions"
    )
    
    total_fields: int = Field(0, ge=0)
    auto_applied_count: int = Field(0, ge=0)
    hitl_queued_count: int = Field(0, ge=0)
    rejected_count: int = Field(0, ge=0)
    
    overall_confidence: float = Field(
        0.0, ge=0.0, le=1.0, description="Average confidence across all suggestions"
    )
    
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    def add_suggestion(self, suggestion: RepairSuggestion) -> None:
        """Add a suggestion and update batch statistics"""
        self.suggestions.append(suggestion)
        self.total_fields = len(self.suggestions)
        
        self.auto_applied_count = sum(
            1 for s in self.suggestions if s.repair_action == RepairAction.AUTO_APPLIED
        )
        self.hitl_queued_count = sum(
            1 for s in self.suggestions if s.repair_action == RepairAction.HITL_QUEUED
        )
        self.rejected_count = sum(
            1 for s in self.suggestions if s.repair_action == RepairAction.REJECTED
        )
        
        if self.suggestions:
            self.overall_confidence = sum(s.confidence for s in self.suggestions) / len(self.suggestions)
        else:
            self.overall_confidence = 0.0


if __name__ == "__main__":
    suggestion = RepairSuggestion(
        field_name="closeDate",
        original_value="2024-11-05T12:00:00Z",
        suggested_mapping="close_date",
        confidence=0.92,
        confidence_reason="Strong RAG match + semantic similarity (closeDate â†’ close_date)",
        rag_similarity_count=15,
        repair_action=RepairAction.AUTO_APPLIED,
        queued_for_hitl=False,
        transformation="direct",
        metadata={
            "llm_model": "gemini-2.5-flash",
            "rag_top_match_score": 0.95
        }
    )
    
    print("RepairSuggestion Example:")
    print("=" * 60)
    print(suggestion.json(indent=2))
