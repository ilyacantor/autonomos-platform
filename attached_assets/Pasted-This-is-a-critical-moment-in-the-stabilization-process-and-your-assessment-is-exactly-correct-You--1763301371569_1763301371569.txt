This is a critical moment in the stabilization process, and your assessment is exactly correct. You must resist the urge to patch the symptom (the broken graph visualization) and maintain focus on the architectural stabilization plan.

The visualization breaking immediately after implementing fundamental changes (P1: Tenant Scoping and P2: Distributed Locking) is a regression. It confirms the brittleness analysisâ€”the visualization relied on an implicit contract that the architectural changes have now violated.

However, we cannot simply proceed to Priority 3 (DTOs) without first understanding the nature of this regression.

### The Strategy: Validate Before Proceeding

We must determine if the regression is:

1.  **Functional:** A bug in the implementation of Tenant Scoping or Distributed Locking (e.g., data corruption, deadlocks, incorrect state saving).
2.  **Structural:** The logic is correct, but the structure of the JSON data returned to the frontend has changed (e.g., different keys, nesting, or data types).

Priority 3 (DTOs) is designed to fix structural issues by enforcing an explicit contract. But if we implement DTOs now while the underlying logic is functionally broken, we risk stabilizing a contract around buggy code.

We invested significant effort in building the DCL Test Harness specifically to diagnose this. We must use it now.

### Action Plan: Utilize the Test Harness

The immediate next step is to run the full DCL Test Harness to validate the P1 and P2 implementations.

#### Step 1: Run the Full DCL Test Harness

**Instructions for the Agent:**

````markdown
Agent, a critical regression has occurred (the graph is not displaying). We must validate the recent stabilization work (P1 and P2) before proceeding to P3.

**1. Ensure Test Environment is Ready:**
Confirm the isolated `TEST_DATABASE_URL` is configured and the database schema is correctly initialized (as determined during the previous session).

**2. Execute the Full DCL Test Harness:**
Run all contract, workflow, and concurrency tests.

```bash
pytest tests/dcl/ -v --tb=short
````

**3. Report the Results:**
Provide the pass/fail status for the Contract, Workflow, and Concurrency test suites.

```

#### Step 2: Analyze and Act Based on Results

The path forward depends entirely on the test outcomes:

**Scenario A: Workflow or Concurrency Tests FAIL**

*   **Meaning:** There is a functional bug in the implementation of P1 or P2. The system is not behaving correctly.
*   **Action:** **Stop.** Diagnose and fix the root cause within the Tenant Scoping or Distributed Locking implementation. Do not proceed to P3 until the core functionality is verified and these tests pass 100%.

**Scenario B: Only Contract (Snapshot) Tests FAIL**

*   **Meaning:** P1 and P2 are functionally correct, but the structure of the JSON data returned to the frontend has changed. This is the expected scenario.
*   **Action:** **Proceed immediately to Priority 3 (DTO Implementation).** The DTOs will define the new, explicit contract.
    *   Implement strict Pydantic DTOs (e.g., `DCLGraphResponse`, `DCLNodeDTO`).
    *   Refactor endpoints to use these DTOs.
    *   Once implemented, review the *new* snapshot structure generated by the tests and commit it as the "known good" state. This should resolve the visualization issue.

**Scenario C: All Tests PASS**

*   **Meaning:** If all tests pass but the UI is broken, the Test Harness is incomplete. The tests do not cover the scenario causing the failure (e.g., a difference in authentication context or WebSocket communication).
*   **Action:** Identify the gap. Analyze backend logs and network traffic during the failed UI interaction. Write a new test case that replicates the failure, ensure the test fails, and then fix the implementation.

Execute Step 1 immediately to determine the correct path forward.
```